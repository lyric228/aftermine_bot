'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

exports.prepare = prepare;
exports.verifyHeader = verifyHeader;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var POINTER_SIZE_IN_BYTES = 4;

var HEADER_SIZE_IN_QUADS = 4;
var HEADER_OFFSET_IN_QUADS = bytesToQuads(272);

var HEAD_OFFSET_IN_QUADS = HEADER_OFFSET_IN_QUADS;
var TAIL_OFFSET_IN_QUADS = HEADER_OFFSET_IN_QUADS + 1;

var PREV_OFFSET_IN_QUADS = 0;
var NEXT_OFFSET_IN_QUADS = 1;
var REF_COUNT_OFFSET_IN_QUADS = 2;
var TYPE_OFFSET_IN_QUADS = 3;

var POINTER_SIZE_IN_QUADS = 1;

var ENTRY_OVERHEAD_IN_BYTES = 16;

var DEFAULT_OPTIONS = {
  lifetime: 0,
  callbackOffset: 0,
  callbacks: {}
};

var GarbageCollector = function () {

  /**
   * Initialize the garbage collector.
   */

  function GarbageCollector(allocator) {
    var _ref = arguments.length <= 1 || arguments[1] === undefined ? DEFAULT_OPTIONS : arguments[1];

    var lifetime = _ref.lifetime;
    var callbacks = _ref.callbacks;
    var callbackOffset = _ref.callbackOffset;

    _classCallCheck(this, GarbageCollector);

    this.allocator = allocator;
    this.lifetime = lifetime || 0;
    this.callbackOffset = callbackOffset || 0;
    this.callbacks = callbacks;
    prepare(this.allocator);
  }

  /**
   * Allocate a given number of bytes and return the offset.
   * If allocation fails, returns 0.
   */


  _createClass(GarbageCollector, [{
    key: 'alloc',
    value: function alloc(numberOfBytes) {
      var type = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];
      var refCount = arguments.length <= 2 || arguments[2] === undefined ? 0 : arguments[2];

      var allocator = this.allocator;
      var address = allocator.alloc(numberOfBytes + ENTRY_OVERHEAD_IN_BYTES);
      if (address === 0) {
        return 0;
      }

      var offset = bytesToQuads(address);
      var int32Array = allocator.int32Array;

      if (refCount > 0) {
        int32Array[offset + REF_COUNT_OFFSET_IN_QUADS] = refCount;
        int32Array[offset + TYPE_OFFSET_IN_QUADS] = type >> 0;
      } else {
        var _tail = int32Array[TAIL_OFFSET_IN_QUADS];
        if (_tail === 0) {
          int32Array[offset] = 0;
          int32Array[HEAD_OFFSET_IN_QUADS] = offset;
          int32Array[TAIL_OFFSET_IN_QUADS] = offset;
        } else {
          int32Array[_tail + NEXT_OFFSET_IN_QUADS] = offset;
          int32Array[offset] = _tail;
          int32Array[TAIL_OFFSET_IN_QUADS] = offset;
        }
        int32Array[offset + NEXT_OFFSET_IN_QUADS] = 0;
        int32Array[offset + REF_COUNT_OFFSET_IN_QUADS] = 0;
        int32Array[offset + TYPE_OFFSET_IN_QUADS] = type >> 0;
      }

      return address + ENTRY_OVERHEAD_IN_BYTES;
    }

    /**
     * Allocate and clear given number of bytes and return the offset.
     * If allocation fails, returns 0.
     */

  }, {
    key: 'calloc',
    value: function calloc(numberOfBytes) {
      var type = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];
      var refCount = arguments.length <= 2 || arguments[2] === undefined ? 0 : arguments[2];

      numberOfBytes = numberOfBytes < 16 ? 16 : align(numberOfBytes);
      var address = this.alloc(numberOfBytes, type, refCount);
      if (address === 0) {
        // No space.
        return 0;
      }


      var int32Array = this.allocator.int32Array;
      var offset = bytesToQuads(address);
      var limit = numberOfBytes / 4;
      for (var i = 0; i < limit; i++) {
        int32Array[offset + i] = 0;
      }
      return address;
    }

    /**
     * Increment the reference count at the given offset and return the new count.
     */

  }, {
    key: 'ref',
    value: function ref(address) {
      var int32Array = this.allocator.int32Array;
      var offset = bytesToQuads(address - ENTRY_OVERHEAD_IN_BYTES);
      var count = int32Array[offset + REF_COUNT_OFFSET_IN_QUADS];

      if (count < 1) {
        var _prev = int32Array[offset];
        var _next = int32Array[offset + NEXT_OFFSET_IN_QUADS];


        if (_prev === 0) {
          int32Array[HEAD_OFFSET_IN_QUADS] = _next;
        } else {
          int32Array[_prev + NEXT_OFFSET_IN_QUADS] = _next;
        }

        if (_next === 0) {
          int32Array[TAIL_OFFSET_IN_QUADS] = _prev;
        } else {
          int32Array[_next] = _prev;
        }
        count = 0;
      }

      count++;

      int32Array[offset + REF_COUNT_OFFSET_IN_QUADS] = count;

      return count;
    }

    /**
     * Decrement the reference count at the given offset and return the new count.
     */

  }, {
    key: 'unref',
    value: function unref(address) {
      var int32Array = this.allocator.int32Array;
      var offset = bytesToQuads(address - ENTRY_OVERHEAD_IN_BYTES);
      var count = int32Array[offset + REF_COUNT_OFFSET_IN_QUADS];


      if (count < 1) {
        // @fixme maybe this should throw?
        return 0;
      } else if (count === 1) {
        var _tail2 = int32Array[TAIL_OFFSET_IN_QUADS];
        if (_tail2 === 0) {
          int32Array[offset] = 0;
          int32Array[HEAD_OFFSET_IN_QUADS] = offset;
          int32Array[TAIL_OFFSET_IN_QUADS] = offset;
        } else {
          int32Array[offset] = _tail2;
          int32Array[_tail2 + NEXT_OFFSET_IN_QUADS] = offset;
          int32Array[TAIL_OFFSET_IN_QUADS] = offset;
        }
        int32Array[offset + NEXT_OFFSET_IN_QUADS] = 0;
        int32Array[offset + REF_COUNT_OFFSET_IN_QUADS] = 0;
        return 0;
      } else {
        int32Array[offset + REF_COUNT_OFFSET_IN_QUADS] = count - 1;
        return count - 1;
      }
    }

    /**
     * Immediately free the block at the given address if its reference count is zero.
     */

  }, {
    key: 'free',
    value: function free(address) {
      var int32Array = this.allocator.int32Array;
      var offset = bytesToQuads(address - ENTRY_OVERHEAD_IN_BYTES);

      if (int32Array[offset + REF_COUNT_OFFSET_IN_QUADS] > 0) {
        return 0;
      }

      var prev = int32Array[offset];
      var next = int32Array[offset + NEXT_OFFSET_IN_QUADS];
      var type = int32Array[offset + TYPE_OFFSET_IN_QUADS];
      if (prev === 0) {
        int32Array[HEAD_OFFSET_IN_QUADS] = next;
      } else {
        int32Array[prev + NEXT_OFFSET_IN_QUADS] = next;
      }

      if (next === 0) {
        int32Array[TAIL_OFFSET_IN_QUADS] = prev;
      } else {
        int32Array[next] = prev;
      }

      if (type !== 0) {
        var callback = this.callbacks[type >>> 0];
        /* istanbul ignore if */
        if (typeof callback === 'function') {
          callback(this.callbackOffset + address);
        }
      }

      return this.allocator.free(address - ENTRY_OVERHEAD_IN_BYTES);
    }

    /**
     * Return the reference count of the block at the given address.
     */

  }, {
    key: 'refCount',
    value: function refCount(address) {
      var int32Array = this.allocator.int32Array;
      var offset = bytesToQuads(address - ENTRY_OVERHEAD_IN_BYTES);
      return int32Array[offset + REF_COUNT_OFFSET_IN_QUADS];
    }

    /**
     * Return the size of the block at the given address.
     */

  }, {
    key: 'sizeOf',
    value: function sizeOf(address) {
      return this.allocator.sizeOf(address - ENTRY_OVERHEAD_IN_BYTES) - ENTRY_OVERHEAD_IN_BYTES;
    }

    /**
     * Return the type of the block at the given address.
     */

  }, {
    key: 'typeOf',
    value: function typeOf(address) {
      var int32Array = this.allocator.int32Array;
      var offset = bytesToQuads(address - ENTRY_OVERHEAD_IN_BYTES);
      return int32Array[offset + TYPE_OFFSET_IN_QUADS] >>> 0;
    }

    /**
     * Perform a garbage collection cycle.
     *
     * Walks through the list of blocks with zero references and increments their cycle count.
     * Blocks whose cycle count reaches the threshold will be freed.
     */

  }, {
    key: 'cycle',
    value: function cycle() {
      var allocator = this.allocator;
      var int32Array = allocator.int32Array;
      var total = 0;
      var prev = 0;
      var next = int32Array[HEAD_OFFSET_IN_QUADS];
      while (next !== 0) {
        var _offset = next;
        next = int32Array[_offset + NEXT_OFFSET_IN_QUADS];

        var _cycles = -int32Array[_offset + REF_COUNT_OFFSET_IN_QUADS] + 1;
        if (_cycles >= this.lifetime) {
          if (prev === 0) {
            int32Array[HEAD_OFFSET_IN_QUADS] = next;
          } else {
            int32Array[prev + NEXT_OFFSET_IN_QUADS] = next;
          }

          if (next === 0) {
            int32Array[TAIL_OFFSET_IN_QUADS] = prev;
          }
          var _type = int32Array[_offset + TYPE_OFFSET_IN_QUADS];
          if (_type !== 0) {
            var callback = this.callbacks[_type >>> 0];
            /* istanbul ignore if */
            if (typeof callback === 'function') {
              callback(this.callbackOffset + quadsToBytes(_offset) + ENTRY_OVERHEAD_IN_BYTES);
            }
          }
          total += allocator.free(quadsToBytes(_offset));
        } else {
          int32Array[_offset + REF_COUNT_OFFSET_IN_QUADS] = -_cycles;
          prev = _offset;
        }
      }

      return total;
    }

    /**
     * Inspect the instance.
     */

  }, {
    key: 'inspect',
    value: function inspect() {
      var allocator = this.allocator;
      var int32Array = allocator.int32Array;
      var items = [];
      var next = int32Array[HEAD_OFFSET_IN_QUADS];
      while (next !== 0) {
        var _offset2 = next;
        var _prev2 = int32Array[_offset2];
        next = int32Array[_offset2 + NEXT_OFFSET_IN_QUADS];
        var _cycles2 = -int32Array[_offset2 + REF_COUNT_OFFSET_IN_QUADS];
        var _type2 = int32Array[_offset2 + TYPE_OFFSET_IN_QUADS] >>> 0;
        var _size = allocator.sizeOf(quadsToBytes(_offset2)) - ENTRY_OVERHEAD_IN_BYTES;
        items.push({
          offset: quadsToBytes(_offset2),
          prev: quadsToBytes(_prev2),
          next: quadsToBytes(next),
          type: _type2,
          cycles: _cycles2,
          size: _size
        });
      }
      var head = quadsToBytes(int32Array[HEAD_OFFSET_IN_QUADS]);
      var tail = quadsToBytes(int32Array[TAIL_OFFSET_IN_QUADS]);
      return {
        header: { head: head, tail: tail },
        items: items
      };
    }
  }]);

  return GarbageCollector;
}();

/**
 * Align the given value to 8 bytes.
 */


exports.default = GarbageCollector;
function align(value) {
  return value + 7 & ~7;
}

/**
 * Ensure that the first block in the given allocator is our header, and if not, create it.
 */
function prepare(allocator) {
  if (!verifyHeader(allocator)) {
    writeInitialHeader(allocator);
  }
  return allocator;
}

/**
 * Verify that the allocator contains a valid header.
 */
function verifyHeader(allocator) {
  var int32Array = allocator.int32Array;
  return int32Array[HEADER_OFFSET_IN_QUADS - 1] === -HEADER_SIZE_IN_QUADS && int32Array[HEADER_OFFSET_IN_QUADS + HEADER_SIZE_IN_QUADS] === -HEADER_SIZE_IN_QUADS;
}

/**
 * Write the initial header for an empty int32Array.
 */
function writeInitialHeader(allocator) {
  var int32Array = allocator.int32Array;
  var header = bytesToQuads(allocator.alloc(quadsToBytes(HEADER_SIZE_IN_QUADS)));
  /* istanbul ignore if  */
  if (header !== HEADER_OFFSET_IN_QUADS) {
    throw new Error('Allocator supplied an invalid start address, expected ' + quadsToBytes(HEADER_OFFSET_IN_QUADS) + ' got ' + quadsToBytes(header));
  }
  int32Array[HEAD_OFFSET_IN_QUADS] = 0;
  int32Array[TAIL_OFFSET_IN_QUADS] = 0;
}

/**
 * Convert quads to bytes.
 */
function quadsToBytes(num) {
  return num * POINTER_SIZE_IN_BYTES;
}

/**
 * Convert bytes to quads.
 */
function bytesToQuads(num) {
  return Math.ceil(num / POINTER_SIZE_IN_BYTES);
}